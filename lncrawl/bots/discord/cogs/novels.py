import asyncio
import io
import math
import os
import shutil
import discord
import logging
import redis
from discord.ext import commands
from typing import Callable, Tuple

from lncrawl.core.app import App
from lncrawl.core.crawler import Crawler
from lncrawl.utils.uploader import upload
from ..utils import to_thread, validate_formats
from ..config import available_formats
from ....core.sources import prepare_crawler

logger = logging.getLogger(__name__)


@to_thread
def download_novel(app: App) -> list:
    try:
        app.pack_by_volume = False
        app.start_download()
        app.bind_books()
        app.compress_books()
        assert isinstance(app.archived_outputs, list)
        return app.archived_outputs
    except Exception as ex:
        logger.exception(ex)


@to_thread
def novel_by_url(url: str) -> App:
    app = App()
    app.user_input = url
    app.crawler = prepare_crawler(app.user_input)
    app.get_novel_info()
    assert isinstance(app.crawler, Crawler)
    return app


@to_thread
def upload_file(archive: str) -> str | io.BufferedIOBase | None:
    # Check file size
    file_size = os.stat(archive).st_size
    if file_size >= 8388608:
        try:
            description = "Generated by: lncrawl Discord bot"
            return upload(archive, description)
        except Exception as e:
            logger.error("Failed to upload file: %s", archive, e)
            return None

    return open(archive, "rb")


def archive_metadata(archive) -> Tuple[str, str]:
    return os.path.basename(os.path.dirname(archive)), os.path.basename(archive)


async def update_progress(app: App, editFollowup: Callable[[str], None]):
    chapterCount = len(app.chapters)
    lastProgress = 0
    while app.crawler.future_progress < chapterCount:
        # this is shit, but it ensures we won't be stuck if we miss the done window
        if app.crawler.future_progress < lastProgress:
            break
        lastProgress = app.crawler.future_progress
        await editFollowup(f"Download in progress: {lastProgress}/{chapterCount}")
        await asyncio.sleep(1)
    # not cool, but we're risking this property to be reset by further downloads
    await editFollowup(f"Done: {chapterCount}/{chapterCount}. Uploading your file.")


def build_hash_novel_key(app: App, start: float, end: float, format: str) -> str:
    return ":".join(
        [
            "files",
            app.good_file_name,
            f"{int(start)}_{'' if math.isinf(end) else str(int(end))}",
            format,
        ]
    )


async def get_hash_value(redis: redis.Redis, hash: str, source: str) -> str | None:
    return await redis.hget(
        name=hash,
        key=source,
    )


def configure_output_path(app: App):
    # set output path
    root = os.path.abspath(".discord_bot_output")
    output_path = os.path.join(root, app.good_source_name, app.good_file_name)
    shutil.rmtree(output_path, ignore_errors=True)
    os.makedirs(output_path, exist_ok=True)
    return output_path


class Novels(commands.Cog):
    def __init__(self, bot):
        self.bot: discord.Bot = bot
        self.redis: redis.Redis = self.bot.get_redis()

    @discord.slash_command(name="download", description="Download a novel by URL")
    @discord.option("url", description="Novel URL")
    @discord.option("start", description="Start chapter", default=0)
    @discord.option("end", description="End chapter", default=math.inf)
    @discord.option(
        "formats", description="Comma separated target formats", default="epub"
    )
    async def download(
        self,
        ctx: discord.ApplicationContext,
        url: str,
        start: float,
        end: float,
        formats: str,
    ):
        if not url.startswith("http"):
            await ctx.respond("You specified an invalid URL")
            return
        formats_list = list(map(str.strip, formats.split(",")))
        if not validate_formats(formats_list):
            fs = ", ".join(available_formats)
            await ctx.respond(
                f"The format you specified is invalid, the available formats are: {fs}"
            )
        # start thinking
        await ctx.defer()

        app: App = await novel_by_url(url)
        embed = discord.Embed(
            title=app.crawler.novel_title,
            url=app.crawler.novel_url,
            description=app.crawler.novel_synopsis,
        )
        embed.set_thumbnail(url=app.crawler.novel_cover)
        embed.add_field(name="Author", value=app.crawler.novel_author, inline=False)
        embed.add_field(name="Volumes", value=len(app.crawler.volumes))
        embed.add_field(name="Chapters", value=len(app.crawler.chapters))
        await ctx.respond(embed=embed)

        # check if we have this cached
        # todo: use HKEYS and check if there are other sources, propose those to the user
        existingFiles = {
            k: await get_hash_value(
                redis=self.redis,
                hash=build_hash_novel_key(app, start, end, k),
                source=app.good_source_name,
            )
            for k in formats_list
        }
        for fmt, cachedUrl in existingFiles.items():
            if not cachedUrl:
                continue
            logger.debug("format %s exists: %s", fmt, cachedUrl)
            formats_list.remove(fmt)
            await ctx.respond(f"**{fmt}**: {cachedUrl}")

        if not formats_list:
            logger.debug("no formats left to dl, returning")
            return

        # set chapters
        if math.isinf(end):
            app.chapters = app.crawler.chapters[int(start) :]
        else:
            app.chapters = app.crawler.chapters[int(start) : int(end)]

        followUp = await ctx.respond(
            f"I don't have this file, downloading {len(app.chapters)} chapters, this will take a while."
        )

        # set formats
        app.output_formats = {x: (x in formats_list) for x in available_formats}
        # set up directories
        app.output_path = configure_output_path(app)
        # update the user with dl progress
        progress_report = update_progress(app, followUp.edit)
        asyncio.create_task(progress_report)

        # start the download
        archive_list = await download_novel(app)

        for archive in archive_list:
            archive_format, archive_name = archive_metadata(archive)
            result = await upload_file(archive)
            if isinstance(result, str):
                await ctx.respond(f"Download URL: {result}")
            elif isinstance(result, io.BufferedReader):
                fileResponse = await ctx.respond(
                    file=discord.File(filename=archive_name, fp=result)
                )
                attachment, *_ = fileResponse.attachments
                # files:novel_name:1_12329:fb2 source_name https://source
                await self.redis.hset(
                    name=build_hash_novel_key(app, start, end, archive_format),
                    key=app.good_source_name,
                    value=attachment.url,
                )
            else:
                await ctx.respond(f"Failed to upload {archive_name}")


def setup(bot):  # this is called by Pycord to setup the cog
    bot.add_cog(Novels(bot))  # add the cog to the bot
