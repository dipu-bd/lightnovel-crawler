import asyncio
import io
import math
import os
import shutil
import discord
import logging
import redis
from discord.ext import commands
from typing import Callable

from lncrawl.core.app import App
from lncrawl.core.crawler import Crawler
from lncrawl.utils.uploader import upload
from ..utils import to_thread, validate_formats
from ..config import available_formats
from ....core.sources import prepare_crawler

logger = logging.getLogger(__name__)


@to_thread
def download_novel(app: App) -> list:
    try:
        app.pack_by_volume = False
        app.start_download()
        app.bind_books()
        app.compress_books()
        assert isinstance(app.archived_outputs, list)
        return app.archived_outputs
    except Exception as ex:
        logger.exception(ex)


@to_thread
def novel_by_url(url) -> discord.ApplicationContext:
    app = App()
    app.user_input = url
    app.crawler = prepare_crawler(app.user_input)
    app.get_novel_info()
    assert isinstance(app.crawler, Crawler)
    return app


@to_thread
def upload_file(archive) -> str | io.BufferedIOBase:
    # Check file size
    filename = os.path.basename(archive)
    file_size = os.stat(archive).st_size
    if file_size >= 8388608:
        try:
            description = "Generated by: lncrawl Discord bot"
            return filename, upload(archive, description)
        except Exception as e:
            logger.error("Failed to upload file: %s", archive, e)
            return filename, None

    return filename, open(archive, "rb")


def get_filename(archive) -> str:
    return os.path.basename(archive)


async def update_progress(app: App, editFollowup: Callable[[str], None]):
    chapterCount = len(app.chapters)
    lastProgress = 0
    while app.crawler.future_progress < chapterCount:
        # this is shit, but it ensures we won't be stuck if we miss the done window
        if app.crawler.future_progress < lastProgress:
            break
        lastProgress = app.crawler.future_progress
        await editFollowup(f"Download in progress: {lastProgress}/{chapterCount}")
        await asyncio.sleep(1)
    # not cool, but we're risking this property to be reset by further downloads
    await editFollowup(f"Done: {chapterCount}/{chapterCount}. Uploading your file.")


def build_novel_key(app: App, start: float, end: float) -> str:
    start_str = str(int(start))
    end_str = "" if math.isinf(end) else str(int(end))
    return ":".join([app.good_source_name, app.good_file_name, start_str, end_str])


class Novels(commands.Cog):
    def __init__(self, bot):
        self.bot: discord.Bot = bot
        self.redis: redis.Redis = self.bot.get_redis()

    @discord.slash_command(name="download", description="Download a novel by URL")
    @discord.option("url", description="Novel URL")
    @discord.option("start", description="Start chapter", default=0)
    @discord.option("end", description="End chapter", default=math.inf)
    @discord.option(
        "formats", description="Comma separated target formats", default="epub"
    )
    async def download(
        self,
        ctx: discord.ApplicationContext,
        url: str,
        start: float,
        end: float,
        formats: str,
    ):
        if not url.startswith("http"):
            await ctx.respond("You specified an invalid URL")
            return
        formats_list = list(map(str.strip, formats.split(",")))
        logger.info(formats_list)
        if not validate_formats(formats_list):
            fs = ", ".join(available_formats)
            await ctx.respond(
                f"The format you specified is invalid, the available formats are: {fs}"
            )
        # start thinking
        await ctx.defer()

        app = await novel_by_url(url)
        embed = discord.Embed(
            title=app.crawler.novel_title,
            url=app.crawler.novel_url,
            description=app.crawler.novel_synopsis,
        )
        embed.set_thumbnail(url=app.crawler.novel_cover)
        embed.add_field(name="Author", value=app.crawler.novel_author, inline=False)
        embed.add_field(name="Volumes", value=len(app.crawler.volumes))
        embed.add_field(name="Chapters", value=len(app.crawler.chapters))
        await ctx.respond(embed=embed)

        # set chapters
        if math.isinf(end):
            app.chapters = app.crawler.chapters[int(start) :]
        else:
            app.chapters = app.crawler.chapters[int(start) : int(end)]

        # set formats
        app.output_formats = {x: (x in formats_list) for x in available_formats}

        # set output path
        root = os.path.abspath(".discord_bot_output")
        app.output_path = os.path.join(root, app.good_source_name, app.good_file_name)
        shutil.rmtree(app.output_path, ignore_errors=True)
        os.makedirs(app.output_path, exist_ok=True)

        followUp = await ctx.respond(
            f"I don't have this file, downloading {len(app.chapters)} chapters, this will take a while."
        )
        progress_report = update_progress(app, followUp.edit)
        asyncio.create_task(progress_report)

        archive_list = await download_novel(app)

        for archive in archive_list:
            filename, result = await upload_file(archive)
            if isinstance(result, str):
                await ctx.respond(f"Download URL: {result}")
            elif isinstance(result, io.BufferedReader):
                fileResponse = await ctx.respond(
                    file=discord.File(filename=filename, fp=result)
                )
                attachment, *_ = fileResponse.attachments
                logger.info(attachment.url)
                # files:example.com:1_12329:fb2
                await self.redis.set(
                    name=build_novel_key(app, start, end), value=attachment.url
                )
                # attachment.url
                # logger.info(fileResponse.content)
            else:
                await ctx.respond(f"Failed to upload {filename}")

    # @discord.slash_command(name="hello", description="Say hello to the bot")
    # async def hello(self, ctx):
    #     await ctx.respond("Hey!")

    @discord.slash_command(name="goodbye", description="Say goodbye to the bot")
    async def goodbye(self, ctx):
        await ctx.respond("Goodbye!")


def setup(bot):  # this is called by Pycord to setup the cog
    bot.add_cog(Novels(bot))  # add the cog to the bot
